name: Handle rejected checks

on:
  issues:
    types: [labeled, unlabeled]

# Prevent concurrent CSV writes - wait for other workflows to finish
concurrency:
  group: csv-write
  cancel-in-progress: false

permissions:
  contents: write
  issues: write

jobs:
  handle-rejection:
    runs-on: ubuntu-latest
    if: github.event.action == 'labeled' && github.event.label.name == 'rejected'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Pull latest changes (prevent race conditions)
        run: |
          git pull --rebase origin main || git pull origin main

      - name: Extract issue data and determine rejection reason
        id: extract
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get issue body and labels
          ISSUE_DATA=$(gh issue view ${{ github.event.issue.number }} --json body,labels)
          ISSUE_BODY=$(echo "$ISSUE_DATA" | jq -r '.body // ""')
          LABELS=$(echo "$ISSUE_DATA" | jq -r '.labels[].name' | tr '\n' ' ')

          # Extract location_id from issue body (multiple formats)
          LOCATION_ID=$(echo "$ISSUE_BODY" | grep -oP 'Location-ID:\*\*\s*`\K[^`]+' || \
                        echo "$ISSUE_BODY" | grep -oP '### Location-ID\s*\n+\K[A-Z]{2}-[A-Z]{2}-\d+' || \
                        echo "$ISSUE_BODY" | grep -oP 'Location-ID\s*\n+\K[A-Z]{2}-[A-Z]{2}-\d+' || \
                        echo "$ISSUE_BODY" | grep -oP 'DE-BE-\d{5}' | head -1 || echo "")
          echo "location_id=$LOCATION_ID" >> $GITHUB_OUTPUT

          # Extract submitter_id from issue body
          SUBMITTER_ID=$(echo "$ISSUE_BODY" | grep -oP 'Submitter ID:\*\*\s*`\K[^`]+' || echo "")
          echo "submitter_id=$SUBMITTER_ID" >> $GITHUB_OUTPUT

          # Extract submitted_at date
          SUBMITTED_AT=$(echo "$ISSUE_BODY" | grep -oP '### Datum und Uhrzeit[^\n]*\n+\K[^\n]+' | head -1 || \
                         echo "$ISSUE_BODY" | grep -oP 'Datum und Uhrzeit[^*]*\*\*\s*`?\K[^`\n]+' | head -1 || echo "")
          echo "submitted_at=$SUBMITTED_AT" >> $GITHUB_OUTPUT

          # Determine check type
          CHECK_TYPE="base"
          if echo "$LABELS" | grep -q "critical"; then
            CHECK_TYPE="critical_change"
          fi
          echo "check_type=$CHECK_TYPE" >> $GITHUB_OUTPUT

          # Check for specific rejection reason labels
          if echo "$LABELS" | grep -q "reject:cooldown"; then
            REASON="Der Ort befindet sich noch im **Cooldown** (90 Tage seit dem letzten gültigen Check). Bitte prüfe auf der [Übersichtsseite](https://satoshiinberlin.github.io/sats4berlin/), wann der nächste Check möglich ist."
            HAS_REASON_LABEL="true"
          elif echo "$LABELS" | grep -q "reject:proof-missing"; then
            REASON="**Nachweise unvollständig.** Bitte stelle sicher, dass alle vier Nachweise (Bon, Bitcoin-Zahlung, Ort erkennbar, öffentlicher Post) vorhanden und gültig sind."
            HAS_REASON_LABEL="true"
          elif echo "$LABELS" | grep -q "reject:proof-invalid"; then
            REASON="**Nachweise nicht akzeptiert.** Die eingereichten Belege konnten nicht verifiziert werden oder entsprechen nicht den Anforderungen."
            HAS_REASON_LABEL="true"
          elif echo "$LABELS" | grep -q "reject:no-bitcoin-payment"; then
            REASON="**Keine Bitcoin-Zahlung erkennbar.** Der Nachweis zeigt keine eindeutige Bitcoin-Transaktion (Lightning/On-Chain)."
            HAS_REASON_LABEL="true"
          elif echo "$LABELS" | grep -q "reject:wrong-location"; then
            REASON="**Falscher Ort.** Die Location-ID stimmt nicht mit dem besuchten Ort überein oder der Ort liegt nicht in Berlin."
            HAS_REASON_LABEL="true"
          elif echo "$LABELS" | grep -q "reject:duplicate"; then
            REASON="**Duplikat.** Für diesen Ort wurde bereits ein Check im aktuellen Zeitraum eingereicht."
            HAS_REASON_LABEL="true"
          elif echo "$LABELS" | grep -q "reject:old-proof"; then
            REASON="**Veraltete Nachweise.** Die Belege sind nicht aktuell oder das Datum ist nicht eindeutig erkennbar."
            HAS_REASON_LABEL="true"
          else
            REASON="Der Check konnte nicht akzeptiert werden. Bei Fragen wende dich bitte an die Maintainer."
            HAS_REASON_LABEL="false"
          fi

          # Use heredoc for multi-line reason
          echo "reason<<REASON_EOF" >> $GITHUB_OUTPUT
          echo "$REASON" >> $GITHUB_OUTPUT
          echo "REASON_EOF" >> $GITHUB_OUTPUT
          echo "has_reason_label=$HAS_REASON_LABEL" >> $GITHUB_OUTPUT

      - name: Warn if no specific rejection reason
        if: steps.extract.outputs.has_reason_label == 'false'
        run: |
          echo "::warning::No specific rejection reason label found. Consider adding one of: reject:cooldown, reject:proof-missing, reject:proof-invalid, reject:no-bitcoin-payment, reject:wrong-location, reject:duplicate, reject:old-proof"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Record rejection in CSV
        run: |
          python3 << 'EOF'
          import csv
          from pathlib import Path
          import datetime

          CHECKS = Path("data/checks_public.csv")
          issue_number = "${{ github.event.issue.number }}"
          check_id = f"ISSUE-{issue_number}"
          today = datetime.date.today().isoformat()
          reason = """${{ steps.extract.outputs.reason }}"""
          location_id = "${{ steps.extract.outputs.location_id }}"
          submitter_id = "${{ steps.extract.outputs.submitter_id }}"
          submitted_at = "${{ steps.extract.outputs.submitted_at }}"
          check_type = "${{ steps.extract.outputs.check_type }}"

          # Check if entry already exists
          rows, fields = [], []
          if CHECKS.exists():
              with CHECKS.open(newline="", encoding="utf-8") as f:
                  r = csv.DictReader(f)
                  fields = r.fieldnames or []
                  rows = list(r)

          existing = {r.get("check_id") for r in rows}
          if check_id in existing:
              # Update existing entry
              for row in rows:
                  if row.get("check_id") == check_id:
                      row["review_status"] = "rejected"
                      row["reviewed_at"] = today
                      row["rejection_reason_public"] = reason[:500]
                      # Update location_id if we extracted it and it wasn't set
                      if location_id and not row.get("location_id"):
                          row["location_id"] = location_id
                      print(f"Updated {check_id} as rejected")
                      break
          else:
              # Entry doesn't exist yet, create record with extracted data
              if fields:
                  new_row = {f: "" for f in fields}
                  new_row["check_id"] = check_id
                  new_row["location_id"] = location_id
                  new_row["submitter_id"] = submitter_id
                  new_row["submitted_at"] = submitted_at
                  new_row["check_type"] = check_type
                  new_row["review_status"] = "rejected"
                  new_row["reviewed_at"] = today
                  new_row["rejection_reason_public"] = reason[:500]
                  rows.append(new_row)
                  print(f"Created rejected entry for {check_id} (location: {location_id or 'unknown'})")

          if fields:
              with CHECKS.open("w", newline="", encoding="utf-8") as f:
                  w = csv.DictWriter(f, fieldnames=fields)
                  w.writeheader()
                  for row in rows:
                      w.writerow(row)
          EOF

      - name: Copy to docs/data for GitHub Pages
        run: |
          ./scripts/copy_to_docs.sh

      - name: Commit and push
        run: |
          git config user.name "sfb-bot"
          git config user.email "sfb-bot@users.noreply.github.com"
          git add data/checks_public.csv docs/data/checks_public.csv
          git diff --cached --quiet || git commit -m "Record rejection for ISSUE-${{ github.event.issue.number }}"
          git push

      - name: Comment on issue with rejection reason
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment ${{ github.event.issue.number }} --body "## ❌ Check nicht akzeptiert

          ${{ steps.extract.outputs.reason }}

          ---

          **Was nun?**
          - Prüfe die Ablehnungsgründe und die [Regeln](https://github.com/${{ github.repository }}/blob/main/RULES.md)
          - Bei Fragen oder wenn du glaubst, dass ein Fehler vorliegt, kommentiere dieses Issue
          - Du kannst einen neuen Check einreichen, sobald die Voraussetzungen erfüllt sind

          ---
          *Automatische Nachricht von sats4berlin-bot*"

      - name: Close issue
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue close ${{ github.event.issue.number }}

  undo-rejection:
    runs-on: ubuntu-latest
    if: github.event.action == 'unlabeled' && github.event.label.name == 'rejected'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Pull latest changes (prevent race conditions)
        run: |
          git pull --rebase origin main || git pull origin main

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Revert rejection in CSV
        run: |
          python3 << 'EOF'
          import csv
          from pathlib import Path

          CHECKS = Path("data/checks_public.csv")
          issue_number = "${{ github.event.issue.number }}"
          check_id = f"ISSUE-{issue_number}"

          rows, fields = [], []
          if CHECKS.exists():
              with CHECKS.open(newline="", encoding="utf-8") as f:
                  r = csv.DictReader(f)
                  fields = r.fieldnames or []
                  rows = list(r)

          updated = False
          for row in rows:
              if row.get("check_id") == check_id:
                  if row.get("review_status") == "rejected":
                      row["review_status"] = "pending"
                      row["reviewed_at"] = ""
                      row["rejection_reason_public"] = ""
                      updated = True
                      print(f"Reverted {check_id} from rejected to pending")
                  else:
                      print(f"{check_id} was not rejected (status: {row.get('review_status')})")
                  break

          if updated and fields:
              with CHECKS.open("w", newline="", encoding="utf-8") as f:
                  w = csv.DictWriter(f, fieldnames=fields)
                  w.writeheader()
                  for row in rows:
                      w.writerow(row)
          elif not updated:
              print(f"Check {check_id} not found or no update needed")
          EOF

      - name: Copy to docs/data for GitHub Pages
        run: |
          ./scripts/copy_to_docs.sh

      - name: Commit and push
        run: |
          git config user.name "sfb-bot"
          git config user.email "sfb-bot@users.noreply.github.com"
          git add data/checks_public.csv docs/data/checks_public.csv
          git diff --cached --quiet || git commit -m "Revert rejection for ISSUE-${{ github.event.issue.number }}"
          git push

      - name: Comment on issue
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment ${{ github.event.issue.number }} --body "## ↩️ Ablehnung zurückgenommen

          Das \"rejected\" Label wurde entfernt. Der Check-Status wurde auf **pending** zurückgesetzt.

          Der Check kann nun erneut geprüft werden.

          ---
          *Automatische Nachricht von sats4berlin-bot*"

      - name: Reopen issue
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue reopen ${{ github.event.issue.number }} || true
