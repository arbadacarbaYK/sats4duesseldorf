name: Mark check as paid

on:
  issues:
    types: [labeled, unlabeled]

# Prevent concurrent processing of the same issue, but allow different issues in parallel
# Use workflow-specific group to avoid cross-workflow cancellation
concurrency:
  group: ${{ github.workflow }}-issue-${{ github.event.issue.number }}
  cancel-in-progress: false

permissions:
  contents: write
  issues: write

jobs:
  mark-paid:
    runs-on: ubuntu-latest
    if: github.event.action == 'labeled' && github.event.label.name == 'paid'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Pull latest changes (prevent race conditions)
        run: |
          git pull --rebase origin main || git pull origin main

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Update paid status in CSV
        run: |
          python3 << 'EOF'
          import csv
          import json
          from pathlib import Path
          import datetime

          CHECKS = Path("data/checks_public.csv")
          BUDGET = Path("data/budget.json")
          issue_number = "${{ github.event.issue.number }}"
          check_id = f"ISSUE-{issue_number}"
          today = datetime.date.today().isoformat()
          now = datetime.datetime.utcnow().isoformat() + "Z"

          def days_ago(days: int) -> str:
              return (datetime.date.today() - datetime.timedelta(days=days)).isoformat()

          def calculate_activity_factor(submitter_id: str, checks: list) -> tuple[float, int]:
              """
              Recalculate activity factor at payout time based on approved checks in last 90 days.
              """
              cutoff = days_ago(90)
              count = 0
              for chk in checks:
                  if (chk.get("submitter_id", "") == submitter_id and
                      chk.get("review_status") == "approved" and
                      chk.get("reviewed_at", "") >= cutoff):
                      count += 1

              if count >= 10:
                  return 2.0, count
              elif count >= 5:
                  return 1.5, count
              elif count >= 2:
                  return 1.2, count
              else:
                  return 1.0, count

          rows, fields = [], []
          with CHECKS.open(newline="", encoding="utf-8") as f:
              r = csv.DictReader(f)
              fields = r.fieldnames
              rows = list(r)

          updated = False
          for row in rows:
              if row.get("check_id") == check_id:
                  # Recalculate activity factor at payout time
                  submitter_id = row.get("submitter_id", "")
                  if submitter_id:
                      new_factor, check_count = calculate_activity_factor(submitter_id, rows)
                      old_factor = float(row.get("activity_factor", "1.0") or "1.0")

                      # Only update if factor increased (never reduce)
                      if new_factor > old_factor:
                          base_bounty = int(row.get("base_bounty_sats", "10000") or "10000")
                          new_final = int(base_bounty * new_factor)
                          old_final = int(row.get("final_bounty_sats", "0") or "0")

                          row["activity_factor"] = str(new_factor)
                          row["final_bounty_sats"] = str(new_final)
                          print(f"Activity multiplier updated: {old_factor}x -> {new_factor}x ({check_count} checks)")
                          print(f"Bounty updated: {old_final} -> {new_final} sats")

                  row["paid_status"] = "paid"
                  row["paid_at"] = today
                  updated = True
                  print(f"Marked {check_id} as paid")
                  break

          if updated:
              with CHECKS.open("w", newline="", encoding="utf-8") as f:
                  w = csv.DictWriter(f, fieldnames=fields)
                  w.writeheader()
                  for row in rows:
                      w.writerow(row)

              # Recalculate budget from all paid checks
              total_paid = 0
              paid_count = 0
              for row in rows:
                  if row.get("paid_status") == "paid":
                      try:
                          total_paid += int(row.get("final_bounty_sats", 0) or 0)
                          paid_count += 1
                      except ValueError:
                          pass

              total_budget = 1000000
              budget_data = {
                  "total_budget_sats": total_budget,
                  "total_paid_sats": total_paid,
                  "remaining_sats": total_budget - total_paid,
                  "paid_count": paid_count,
                  "last_updated": now
              }
              with BUDGET.open("w", encoding="utf-8") as f:
                  json.dump(budget_data, f, indent=2)
              print(f"Budget updated: {total_paid} paid, {total_budget - total_paid} remaining")
          else:
              print(f"Check {check_id} not found in CSV")
          EOF

      - name: Generate leaderboard
        run: |
          python scripts/generate_leaderboard.py

      - name: Copy to docs/data for GitHub Pages
        run: |
          ./scripts/copy_to_docs.sh

      - name: Commit and push
        run: |
          git config user.name "sfb-bot"
          git config user.email "sfb-bot@users.noreply.github.com"
          git add data/checks_public.csv data/budget.json data/leaderboard.json docs/data/checks_public.csv docs/data/budget.json docs/data/leaderboard.json
          git diff --cached --quiet || git commit -m "Mark ISSUE-${{ github.event.issue.number }} as paid"
          # Retry push with rebase if another workflow pushed first
          git push || (git pull --rebase origin main && git push)

      - name: Comment on issue
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment ${{ github.event.issue.number }} --body "## üí∞ Bounty ausgezahlt!

          Die Auszahlung f√ºr diesen Check wurde verarbeitet.

          Vielen Dank f√ºr deinen Beitrag zu **Satoshis f√ºr Berlin**!

          ---
          *Automatische Nachricht von sats4berlin-bot*"

      - name: Close issue
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue close ${{ github.event.issue.number }}

  unmark-paid:
    runs-on: ubuntu-latest
    if: github.event.action == 'unlabeled' && github.event.label.name == 'paid'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Pull latest changes (prevent race conditions)
        run: |
          git pull --rebase origin main || git pull origin main

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Revert paid status in CSV
        run: |
          python3 << 'EOF'
          import csv
          import json
          from pathlib import Path
          import datetime

          CHECKS = Path("data/checks_public.csv")
          BUDGET = Path("data/budget.json")
          issue_number = "${{ github.event.issue.number }}"
          check_id = f"ISSUE-{issue_number}"
          now = datetime.datetime.utcnow().isoformat() + "Z"

          rows, fields = [], []
          with CHECKS.open(newline="", encoding="utf-8") as f:
              r = csv.DictReader(f)
              fields = r.fieldnames
              rows = list(r)

          updated = False
          reverted_amount = 0
          for row in rows:
              if row.get("check_id") == check_id:
                  if row.get("paid_status") == "paid":
                      reverted_amount = int(row.get("final_bounty_sats", 0) or 0)
                      row["paid_status"] = "pending"
                      row["paid_at"] = ""
                      updated = True
                      print(f"Reverted {check_id} to pending (was {reverted_amount} sats)")
                  else:
                      print(f"{check_id} was not marked as paid, no change needed")
                  break

          if updated:
              with CHECKS.open("w", newline="", encoding="utf-8") as f:
                  w = csv.DictWriter(f, fieldnames=fields)
                  w.writeheader()
                  for row in rows:
                      w.writerow(row)

              # Recalculate budget from all paid checks
              total_paid = 0
              paid_count = 0
              for row in rows:
                  if row.get("paid_status") == "paid":
                      try:
                          total_paid += int(row.get("final_bounty_sats", 0) or 0)
                          paid_count += 1
                      except ValueError:
                          pass

              total_budget = 1000000
              budget_data = {
                  "total_budget_sats": total_budget,
                  "total_paid_sats": total_paid,
                  "remaining_sats": total_budget - total_paid,
                  "paid_count": paid_count,
                  "last_updated": now
              }
              with BUDGET.open("w", encoding="utf-8") as f:
                  json.dump(budget_data, f, indent=2)
              print(f"Budget updated: {total_paid} paid, {total_budget - total_paid} remaining")
          else:
              print(f"Check {check_id} not found in CSV or no update needed")
          EOF

      - name: Generate leaderboard
        run: |
          python scripts/generate_leaderboard.py

      - name: Copy to docs/data for GitHub Pages
        run: |
          ./scripts/copy_to_docs.sh

      - name: Commit and push
        run: |
          git config user.name "sfb-bot"
          git config user.email "sfb-bot@users.noreply.github.com"
          git add data/checks_public.csv data/budget.json data/leaderboard.json docs/data/checks_public.csv docs/data/budget.json docs/data/leaderboard.json
          git diff --cached --quiet || git commit -m "Revert paid status for ISSUE-${{ github.event.issue.number }}"
          # Retry push with rebase if another workflow pushed first
          git push || (git pull --rebase origin main && git push)

      - name: Comment on issue
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment ${{ github.event.issue.number }} --body "## ‚Ü©Ô∏è Zahlung zur√ºckgesetzt

          Das \"paid\" Label wurde entfernt. Der Zahlungsstatus wurde auf **pending** zur√ºckgesetzt und das Budget wurde korrigiert.

          ---
          *Automatische Nachricht von sats4berlin-bot*"

      - name: Reopen issue
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue reopen ${{ github.event.issue.number }}
