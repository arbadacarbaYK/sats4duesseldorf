name: Apply approved issues to CSV (v1)

on:
  workflow_dispatch:
  issues:
    types: [labeled, unlabeled]

# Prevent concurrent processing of the same issue, but allow different issues in parallel
# Use workflow-specific group to avoid cross-workflow cancellation
concurrency:
  group: ${{ github.workflow }}-issue-${{ github.event.issue.number || 'manual' }}
  cancel-in-progress: false

permissions:
  contents: write
  issues: write

jobs:
  apply:
    runs-on: ubuntu-latest
    # Run on manual trigger OR when "approved" label is added
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issues' && github.event.action == 'labeled' && github.event.label.name == 'approved')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Pull latest changes (prevent race conditions)
        run: |
          git pull --rebase origin main || git pull origin main

      - name: Install GitHub CLI (gh)
        run: |
          sudo apt-get update
          sudo apt-get install -y gh

      - name: Fetch approved issues (raw JSON)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          mkdir -p data
          gh api -H "Accept: application/vnd.github+json" \
            "/repos/${GITHUB_REPOSITORY}/issues?state=all&labels=approved&per_page=100" \
            > data/_approved_issues.json
          echo "Saved approved issues to data/_approved_issues.json"
          head -c 200 data/_approved_issues.json || true
          echo ""

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Apply to CSV
        run: |
          python scripts/apply_approved_v1.py
          rm -f data/_approved_issues.json

      - name: Copy to docs/data for GitHub Pages
        run: |
          ./scripts/copy_to_docs.sh

      - name: Commit and push
        run: |
          git config user.name "sfb-bot"
          git config user.email "sfb-bot@users.noreply.github.com"
          git add data/locations.csv data/checks_public.csv docs/data/locations.csv docs/data/checks_public.csv
          # Add validation log if it exists (for debugging)
          [ -f data/validation_errors.log ] && git add data/validation_errors.log || true
          git diff --cached --quiet || git commit -m "Apply approved issues (v1)"
          # Retry push with rebase if another workflow pushed first
          git push || (git pull --rebase origin main && git push)

      - name: Comment on approved issue
        if: github.event_name == 'issues' && github.event.label.name == 'approved'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get issue body and labels
          ISSUE_BODY=$(gh issue view ${{ github.event.issue.number }} --json body -q '.body')
          LABELS=$(gh issue view ${{ github.event.issue.number }} --json labels -q '.labels[].name' | tr '\n' ' ')

          # Check if submission came via web form (has Submission ID)
          SUBMISSION_ID=$(echo "$ISSUE_BODY" | grep -oP 'Submission ID:\*\*\s*`\K[^`]+' || echo "")

          # Extract Location-ID from issue body (multiple formats)
          LOCATION_ID=$(echo "$ISSUE_BODY" | grep -oP 'Location-ID:\*\*\s*`\K[^`]+' || \
                        echo "$ISSUE_BODY" | grep -oP '### Location-ID\s*\n+\K[A-Z]{2}-[A-Z]{2}-\d+' || \
                        echo "$ISSUE_BODY" | grep -oP 'Location-ID\s*\n+\K[A-Z]{2}-[A-Z]{2}-\d+' || \
                        echo "$ISSUE_BODY" | grep -oP 'DE-BE-\d{5}' | head -1 || echo "")

          # Check if this is a critical change
          IS_CRITICAL=""
          if echo "$LABELS" | grep -q "critical"; then
            IS_CRITICAL="true"
          fi

          # Extract critical change reason
          CRITICAL_REASON=$(echo "$ISSUE_BODY" | grep -oP 'Was ist passiert\?\s*\n+\K[^\n]+' | head -1 || \
                           echo "$ISSUE_BODY" | grep -oP '### Was ist passiert\?\s*\n+\K[^\n]+' | head -1 || echo "")

          # Extract verification details for BTCMap notes using Python (more reliable than grep)
          EXTRACTED=$(python3 << EOF
          import re
          import json

          body = '''$ISSUE_BODY'''

          def extract(pattern, text):
              match = re.search(pattern, text, re.IGNORECASE)
              return match.group(1).strip() if match else ''

          # Support both "### Label\n\nvalue" and "**Label:** value" formats
          check_date = extract(r'### Datum und Uhrzeit[^\n]*\n\n([^\n]+)', body) or \
                       extract(r'\*\*Datum und Uhrzeit[^*]*\*\*\s*\`?([^\`\n]+)', body)

          # PUBLIC_POST can be https://, nostr:, or any content
          public_post = extract(r'### 1\. √ñffentlicher Post[^\n]*\n\n([^\n]+)', body) or \
                        extract(r'\*\*√ñffentlicher Post[^*]*\*\*\s*\`?([^\`\n]+)', body)

          receipt = extract(r'### 2\. Kaufbeleg[^\n]*\n\n(https?://[^\n]+)', body) or \
                    extract(r'### 2\. Kaufnachweis[^\n]*\n\n(https?://[^\n]+)', body) or \
                    extract(r'\*\*Kaufbeleg[^*]*\*\*\s*\`?([^\`\n]+)', body)

          payment = extract(r'### 3\. Bitcoin-Zahlung[^\n]*\n\n(https?://[^\n]+)', body) or \
                    extract(r'\*\*Bitcoin-Zahlung[^*]*\*\*\s*\`?([^\`\n]+)', body)

          venue = extract(r'### 4\. Foto vom Ort[^\n]*\n\n(https?://[^\n]+)', body) or \
                  extract(r'\*\*Foto vom Ort[^*]*\*\*\s*\`?([^\`\n]+)', body)

          observations = extract(r'### Wie lief die Zahlung[^\n]*\n\n([^\n]+)', body) or \
                         extract(r'\*\*Wie lief die Zahlung[^*]*\*\*\s*([^\n]+)', body)

          # Output as JSON for safe parsing
          print(json.dumps({
              'check_date': check_date,
              'public_post': public_post,
              'receipt': receipt,
              'payment': payment,
              'venue': venue,
              'observations': observations
          }))
          EOF
          )

          CHECK_DATE=$(echo "$EXTRACTED" | python3 -c "import sys,json; print(json.load(sys.stdin).get('check_date',''))")
          PUBLIC_POST=$(echo "$EXTRACTED" | python3 -c "import sys,json; print(json.load(sys.stdin).get('public_post',''))")
          RECEIPT_URL=$(echo "$EXTRACTED" | python3 -c "import sys,json; print(json.load(sys.stdin).get('receipt',''))")
          PAYMENT_URL=$(echo "$EXTRACTED" | python3 -c "import sys,json; print(json.load(sys.stdin).get('payment',''))")
          VENUE_URL=$(echo "$EXTRACTED" | python3 -c "import sys,json; print(json.load(sys.stdin).get('venue',''))")
          OBSERVATIONS=$(echo "$EXTRACTED" | python3 -c "import sys,json; print(json.load(sys.stdin).get('observations',''))")

          # Extract pseudonym from issue body
          PSEUDONYM=$(echo "$ISSUE_BODY" | grep -oP '\*\*Submitter:\*\*\s*\K[^\n]+' | head -1 || echo "anonymous user")

          # Look up OSM info from locations.csv using Python for proper CSV parsing
          BTCMAP_LINK=""
          OSM_LINK=""
          LOCATION_NAME=""
          if [ -n "$LOCATION_ID" ] && [ -f "data/locations.csv" ]; then
            OSM_INFO=$(python3 << EOF
          import csv
          location_id = "$LOCATION_ID"
          with open("data/locations.csv", newline="", encoding="utf-8") as f:
              for row in csv.DictReader(f):
                  if row.get("location_id") == location_id:
                      osm_type = row.get("osm_type", "")
                      osm_id = row.get("osm_id", "")
                      name = row.get("name", "").replace("|", " ")  # escape delimiter
                      print(f"{osm_type}|{osm_id}|{name}")
                      break
          EOF
          )
            if [ -n "$OSM_INFO" ]; then
              OSM_TYPE=$(echo "$OSM_INFO" | cut -d'|' -f1)
              OSM_ID=$(echo "$OSM_INFO" | cut -d'|' -f2)
              LOCATION_NAME=$(echo "$OSM_INFO" | cut -d'|' -f3)
              if [ -n "$OSM_TYPE" ] && [ -n "$OSM_ID" ]; then
                BTCMAP_LINK="https://btcmap.org/verify-location?id=${OSM_TYPE}:${OSM_ID}"
                OSM_LINK="https://www.openstreetmap.org/${OSM_TYPE}/${OSM_ID}"
              fi
            fi
          fi

          # Build BTCMap section for maintainer comment
          BTCMAP_SECTION=""
          if [ -n "$BTCMAP_LINK" ]; then
            ISSUE_URL="https://github.com/${{ github.repository }}/issues/${{ github.event.issue.number }}"
            TODAY=$(date +%Y-%m-%d)

            if [ -n "$IS_CRITICAL" ]; then
              # Critical change - location no longer accepts Bitcoin
              BTCMAP_NOTES="CRITICAL: Location no longer accepts Bitcoin (reported ${TODAY})

          Reason: ${CRITICAL_REASON:-Location reported as not accepting Bitcoin anymore}

          Evidence: ${ISSUE_URL}"

              BTCMAP_SECTION="

          ---

          ### ‚ö†Ô∏è BTCMap aktualisieren (KRITISCH)

          **Dieser Ort akzeptiert kein Bitcoin mehr!**

          **[‚û°Ô∏è BTCMap √∂ffnen](${BTCMAP_LINK})**

          Bitte melde die √Ñnderung an BTCMap:
          1. Klicke auf den Link oben
          2. W√§hle \"Report outdated info\" oder \"No longer accepts Bitcoin\"
          3. Kopiere diesen Text als Begr√ºndung:

          \`\`\`
          ${BTCMAP_NOTES}
          \`\`\`

          <details>
          <summary>Links</summary>

          - [OSM-Eintrag](${OSM_LINK})
          - [GitHub Issue](${ISSUE_URL})
          </details>"
            else
              # Normal verification - simple format for BTCMap bot
              BTCMAP_VERIFICATION="Visit by user \"${PSEUDONYM}\" who paid with BTC via Lightning at the location during the \"Satoshis for Berlin\" challenge. For details, see ${ISSUE_URL}"

              BTCMAP_SECTION="

          ---

          ### üó∫Ô∏è BTCMap aktualisieren

          **[‚û°Ô∏è BTCMap Verification √∂ffnen](${BTCMAP_LINK})**

          Kopiere diesen Text in das Feld **\"How did you verify this?\"**:

          \`\`\`
          ${BTCMAP_VERIFICATION}
          \`\`\`

          <details>
          <summary>Weitere Links</summary>

          - [OSM-Eintrag](${OSM_LINK})
          - [GitHub Issue](${ISSUE_URL})
          - Social: ${PUBLIC_POST:-n/a}
          </details>"
            fi
          fi

          if [ -n "$IS_CRITICAL" ]; then
            # Critical change - location no longer accepts Bitcoin
            if [ -n "$SUBMISSION_ID" ]; then
              gh issue comment ${{ github.event.issue.number }} --body "## ‚ö†Ô∏è Kritische √Ñnderung best√§tigt!

          Deine Meldung wurde gepr√ºft und **best√§tigt**. Vielen Dank f√ºr die wichtige Info!

          **${LOCATION_NAME:-Der Ort}** wurde als \"akzeptiert kein Bitcoin mehr\" markiert.

          Die Auszahlung des Bounties erfolgt in K√ºrze an die von dir im Formular angegebene Adresse.
          ${BTCMAP_SECTION}

          ---
          *Automatische Nachricht von sats4berlin-bot*"
            else
              gh issue comment ${{ github.event.issue.number }} --body "## ‚ö†Ô∏è Kritische √Ñnderung best√§tigt!

          Deine Meldung wurde gepr√ºft und **best√§tigt**. Vielen Dank f√ºr die wichtige Info!

          **${LOCATION_NAME:-Der Ort}** wurde als \"akzeptiert kein Bitcoin mehr\" markiert.

          ### N√§chster Schritt: Auszahlungsziel mitteilen

          Bitte sende uns dein Auszahlungsziel **privat** per E-Mail oder Direktnachricht:
          - **Lightning-Adresse** (z.B. name@wallet.com)
          - oder **Cashu-Token-Anfrage**

          Kontakt f√ºr Auszahlung: satoshiinberlin@proton.me
          ${BTCMAP_SECTION}

          ---
          *Automatische Nachricht von sats4berlin-bot*"
            fi
          elif echo "$LABELS" | grep -q "new-location"; then
            # New location - payout held until confirmed
            gh issue comment ${{ github.event.issue.number }} --body "## ‚úÖ Check approved!

          Dein Check wurde gepr√ºft und **approved**.

          **Hinweis f√ºr Neueintr√§ge:** Die Auszahlung erfolgt erst, wenn **2 weitere Bitcoiner** den Ort durch einen eigenen Kauf best√§tigt haben (insgesamt 3 g√ºltige Checks).

          Sobald die Best√§tigungen vorliegen, erfolgt die Auszahlung automatisch an die von dir angegebene Adresse.
          ${BTCMAP_SECTION}

          ---
          *Automatische Nachricht von sats4berlin-bot*"
          elif [ -n "$SUBMISSION_ID" ]; then
            # Submitted via web form - contact info is stored privately
            gh issue comment ${{ github.event.issue.number }} --body "## ‚úÖ Check approved!

          Dein Check wurde gepr√ºft und **approved**. Vielen Dank!

          Die Auszahlung erfolgt in K√ºrze an die von dir im Formular angegebene Adresse.
          ${BTCMAP_SECTION}

          ---
          *Automatische Nachricht von sats4berlin-bot*"
          else
            # Submitted via GitHub form - need to request payout info
            gh issue comment ${{ github.event.issue.number }} --body "## ‚úÖ Check approved!

          Dein Check wurde gepr√ºft und **approved**. Vielen Dank!

          ### N√§chster Schritt: Auszahlungsziel mitteilen

          Bitte sende uns dein Auszahlungsziel **privat** per E-Mail oder Direktnachricht:
          - **Lightning-Adresse** (z.B. name@wallet.com)
          - oder **Cashu-Token-Anfrage**

          ‚ö†Ô∏è **Wichtig:** Poste deine Lightning-Adresse **nicht** √∂ffentlich in diesem Issue!

          Kontakt f√ºr Auszahlung: satoshiinberlin@proton.me
          ${BTCMAP_SECTION}

          ---
          *Automatische Nachricht von sats4berlin-bot*"
          fi

  unapprove:
    runs-on: ubuntu-latest
    # Run when "approved" label is removed
    if: github.event_name == 'issues' && github.event.action == 'unlabeled' && github.event.label.name == 'approved'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Pull latest changes (prevent race conditions)
        run: |
          git pull --rebase origin main || git pull origin main

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Revert approval in CSV
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3 << 'EOF'
          import csv
          import json
          from pathlib import Path
          import datetime

          LOCATIONS = Path("data/locations.csv")
          CHECKS = Path("data/checks_public.csv")
          issue_number = "${{ github.event.issue.number }}"
          check_id = f"ISSUE-{issue_number}"

          # Read checks
          chk_rows, chk_fields = [], []
          with CHECKS.open(newline="", encoding="utf-8") as f:
              r = csv.DictReader(f)
              chk_fields = list(r.fieldnames)
              chk_rows = list(r)

          # Find the check entry
          check_entry = None
          check_idx = None
          for i, row in enumerate(chk_rows):
              if row.get("check_id") == check_id:
                  check_entry = row
                  check_idx = i
                  break

          if not check_entry:
              print(f"Check {check_id} not found in CSV, nothing to revert")
              exit(0)

          location_id = check_entry.get("location_id", "")
          check_type = check_entry.get("check_type", "")
          was_critical = check_type == "critical_change"

          print(f"Reverting {check_id} for location {location_id}")
          print(f"Check type: {check_type}, Critical: {was_critical}")

          # Read locations
          loc_rows, loc_fields = [], []
          with LOCATIONS.open(newline="", encoding="utf-8") as f:
              r = csv.DictReader(f)
              loc_fields = list(r.fieldnames)
              loc_rows = list(r)

          # Find and update the location
          location_updated = False
          for row in loc_rows:
              if row.get("location_id") == location_id:
                  if was_critical:
                      # Revert critical change: restore location to active
                      row["location_status"] = "active"
                      row["eligible_now"] = "yes"
                      row["eligible_for_check"] = "yes"
                      print(f"Restored {location_id} to active status")
                  else:
                      # Revert normal check: reset cooldown and last_verified_at
                      row["cooldown_until"] = ""
                      row["cooldown_days_left"] = "0"
                      row["eligible_now"] = "yes"
                      row["eligible_for_check"] = "yes"
                      row["last_check_id"] = ""
                      row["last_verified_at"] = ""  # Reset so cooldown uses BTCMap date
                      # Decrement verified count
                      try:
                          count = int(row.get("verified_by_count", "0") or "0")
                          new_count = max(0, count - 1)
                          row["verified_by_count"] = str(new_count)

                          # If count drops below 2, revert new_location_status to pending
                          if row.get("new_location_status") == "confirmed" and new_count < 2:
                              row["new_location_status"] = "pending"
                              row["verification_confidence"] = "low"
                              print(f"Reverted {location_id} to pending status (only {new_count} checks remaining)")
                      except ValueError:
                          pass
                      print(f"Reset cooldown for {location_id}")
                  location_updated = True
                  break

          # Mark check as reverted
          check_entry["review_status"] = "reverted"

          # Write back
          with CHECKS.open("w", newline="", encoding="utf-8") as f:
              w = csv.DictWriter(f, fieldnames=chk_fields)
              w.writeheader()
              for row in chk_rows:
                  w.writerow(row)

          with LOCATIONS.open("w", newline="", encoding="utf-8") as f:
              w = csv.DictWriter(f, fieldnames=loc_fields)
              w.writeheader()
              for row in loc_rows:
                  w.writerow(row)

          print(f"Successfully reverted approval for {check_id}")
          EOF

      - name: Copy to docs/data for GitHub Pages
        run: |
          ./scripts/copy_to_docs.sh

      - name: Commit and push
        run: |
          git config user.name "sfb-bot"
          git config user.email "sfb-bot@users.noreply.github.com"
          git add data/locations.csv data/checks_public.csv docs/data/locations.csv docs/data/checks_public.csv
          git diff --cached --quiet || git commit -m "Revert approval for ISSUE-${{ github.event.issue.number }}"
          # Retry push with rebase if another workflow pushed first
          git push || (git pull --rebase origin main && git push)

      - name: Comment on issue
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment ${{ github.event.issue.number }} --body "## ‚Ü©Ô∏è Genehmigung zur√ºckgenommen

          Das \"approved\" Label wurde entfernt. Die √Ñnderungen wurden r√ºckg√§ngig gemacht:
          - Check-Status auf **reverted** gesetzt
          - Location wieder als **verf√ºgbar** markiert

          ---
          *Automatische Nachricht von sats4berlin-bot*"

      - name: Reopen issue
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue reopen ${{ github.event.issue.number }} || true
